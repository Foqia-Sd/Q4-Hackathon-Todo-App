import { RRule, RRuleSet, rrulestr } from 'rrule';

export interface TaskData {
  taskId: string;
  userId: string;
  action: string;
  task: {
    id: string;
    title: string;
    description?: string;
    recurrence_rule?: string;
    due_date?: string;
    priority?: string;
    status: string;
    user_id: string;
    created_at: string;
    updated_at: string;
  };
}

export class RecurrenceService {
  /**
   * Calculate the next occurrence date based on the recurrence rule
   * @param recurrenceRule RRULE string
   * @param lastOccurrence Date of the last occurrence (when task was completed)
   * @returns Date of the next occurrence or null if no further occurrences
   */
  calculateNextOccurrence(recurrenceRule: string, lastOccurrence: Date): Date | null {
    try {
      // Parse the RRULE string
      const rule = rrulestr(recurrenceRule) as RRule | RRuleSet;

      if (rule instanceof RRuleSet) {
        // For RRuleSet, we need to get the first rule or combine rules appropriately
        const dates = rule.between(lastOccurrence, new Date(Date.now() + 365 * 24 * 60 * 60 * 1000)); // Look ahead 1 year
        if (dates.length > 0) {
          return new Date(dates[0]);
        }
        return null;
      } else if (rule instanceof RRule) {
        // For a single RRule, get the next occurrence after the last occurrence
        const nextDates = rule.after(lastOccurrence, true);
        if (nextDates) {
          return new Date(nextDates);
        }
        return null;
      } else {
        throw new Error('Invalid recurrence rule format');
      }
    } catch (error) {
      console.error('Error calculating next occurrence:', error);
      return null;
    }
  }

  /**
   * Validates if a recurrence rule is syntactically correct
   * @param recurrenceRule RRULE string to validate
   * @returns boolean indicating if the rule is valid
   */
  validateRecurrenceRule(recurrenceRule: string): boolean {
    try {
      const rule = rrulestr(recurrenceRule);
      return !!rule;
    } catch (error) {
      console.error('Invalid recurrence rule:', error);
      return false;
    }
  }

  /**
   * Creates a new task object based on the original task and next occurrence date
   * @param originalTask Original task data
   * @param nextOccurrenceDate Date for the next occurrence
   * @returns New task object with updated properties
   */
  createNextTaskFromRecurrence(originalTask: any, nextOccurrenceDate: Date): any {
    // Clone the original task to create a new occurrence
    const newTask = { ...originalTask };

    // Update the ID to be a new unique ID (in practice, this would be generated by the API)
    delete newTask.id;

    // Update the due date to the next occurrence
    newTask.due_date = nextOccurrenceDate.toISOString();

    // Reset the status to pending for the new occurrence
    newTask.status = 'pending';

    // Set the creation date to now
    newTask.created_at = new Date().toISOString();

    // Remove any completion-specific fields
    if (newTask.completed_at) {
      delete newTask.completed_at;
    }

    return newTask;
  }
}